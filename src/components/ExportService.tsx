'use client';

interface ExportService {
  exportAsMarkdown(outputData: any, theme: string): string;
  exportAsJSON(outputData: any, theme: string): string;
  exportAsSVG(blocks: any[], theme: string): string;
  downloadFile(content: string, filename: string, mimeType: string): void;
}

class ThinkingExportService implements ExportService {
  exportAsMarkdown(outputData: any, theme: string): string {
    const { text, json } = outputData;
    const timestamp = new Date().toLocaleString('ja-JP');
    
    const markdown = `# 🧠 思考構造エクスポート

**生成日時:** ${timestamp}  
**テーマ:** ${this.getThemeName(theme)}

## 📝 思考構文

\`\`\`
${text}
\`\`\`

## 🧩 ブロック構造

${this.generateBlockMarkdown(json.thinking_structure?.blocks || [])}

## 💡 考察

この思考構造は以下の要素から構成されています：

${this.generateInsightMarkdown(json.thinking_structure?.blocks || [])}

## 🔗 次のアクション

- [ ] 思考構造を実際の行動計画に落とし込む
- [ ] 他の視点からの検証を行う  
- [ ] 定期的な振り返りと更新を実施する

---
*Generated by THINKING BLOCKS - Program your way of thinking*
`;

    return markdown;
  }

  exportAsJSON(outputData: any, theme: string): string {
    const enrichedData = {
      ...outputData.json,
      metadata: {
        exportedAt: new Date().toISOString(),
        theme: theme,
        version: '1.0.0',
        generator: 'THINKING BLOCKS'
      },
      analysis: {
        blockCount: outputData.blocks?.length || 0,
        hasCompleteFlow: this.checkCompleteFlow(outputData.blocks || []),
        complexity: this.calculateComplexity(outputData.blocks || [])
      }
    };

    return JSON.stringify(enrichedData, null, 2);
  }

  exportAsSVG(blocks: any[], theme: string): string {
    const width = 800;
    const height = 600;
    const themeColors = this.getThemeColors(theme);

    // SVGヘッダー
    let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .title { font-family: 'Quicksand', sans-serif; font-size: 18px; font-weight: bold; fill: ${themeColors.text}; }
      .block-text { font-family: 'Quicksand', sans-serif; font-size: 12px; fill: white; text-anchor: middle; }
      .block-label { font-family: 'Quicksand', sans-serif; font-size: 10px; fill: white; text-anchor: middle; }
    </style>
    <filter id="shadow">
      <feDropShadow dx="2" dy="2" stdDeviation="3" flood-opacity="0.3"/>
    </filter>
  </defs>
  
  <!-- Background -->
  <rect width="${width}" height="${height}" fill="${themeColors.background}"/>
  
  <!-- Title -->
  <text x="${width/2}" y="30" text-anchor="middle" class="title">思考構造マップ</text>`;

    // ブロックの配置とレンダリング
    if (blocks && blocks.length > 0) {
      const positions = this.calculateSVGPositions(blocks, width, height);
      
      blocks.forEach((block, index) => {
        if (block && block.getFieldValue) {
          const pos = positions[index];
          const text = block.getFieldValue('TEXT') || '';
          const blockType = block.type;
          const color = this.getBlockColor(blockType);
          
          // ブロック矩形
          svg += `
  <rect x="${pos.x - 60}" y="${pos.y - 20}" width="120" height="40" rx="20" fill="${color}" filter="url(#shadow)"/>
  <text x="${pos.x}" y="${pos.y - 8}" class="block-label">${blockType.replace('thinking_', '').toUpperCase()}</text>
  <text x="${pos.x}" y="${pos.y + 8}" class="block-text">${this.truncateText(text, 15)}</text>`;
        }
      });

      // 接続線の描画
      svg += this.generateSVGConnections(blocks, positions);
    } else {
      // 空の状態
      svg += `
  <text x="${width/2}" y="${height/2}" text-anchor="middle" fill="${themeColors.text}" font-family="Quicksand" font-size="14">
    思考ブロックを組み立ててSVGを生成してください
  </text>`;
    }

    svg += `
  <!-- Footer -->
  <text x="${width-10}" y="${height-10}" text-anchor="end" fill="${themeColors.text}" font-family="Quicksand" font-size="10">
    THINKING BLOCKS
  </text>
</svg>`;

    return svg;
  }

  downloadFile(content: string, filename: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  private getThemeName(theme: string): string {
    const themeNames: { [key: string]: string } = {
      creative: '創造',
      introspection: '内省',
      research: '研究',
      education: '教育'
    };
    return themeNames[theme] || theme;
  }

  private generateBlockMarkdown(blocks: any[]): string {
    if (!blocks || blocks.length === 0) {
      return '*ブロックが設定されていません*';
    }

    return blocks.map((block, index) => {
      const type = block.type || 'unknown';
      const text = block.text || '';
      const typeDisplay = type.replace('thinking_', '').toUpperCase();
      
      return `### ${index + 1}. ${typeDisplay}ブロック
**内容:** ${text}  
**タイプ:** \`${type}\`  
**位置:** (${block.position?.x || 0}, ${block.position?.y || 0})`;
    }).join('\n\n');
  }

  private generateInsightMarkdown(blocks: any[]): string {
    const blockTypes = blocks.map(b => b.type).filter(Boolean);
    const insights = [];

    if (blockTypes.includes('thinking_why')) {
      insights.push('- **動機の明確化**: WHYブロックで根本的な動機が整理されています');
    }
    if (blockTypes.includes('thinking_how')) {
      insights.push('- **手段の具体化**: HOWブロックで実現方法が検討されています');
    }
    if (blockTypes.includes('thinking_what')) {
      insights.push('- **目標の設定**: WHATブロックで達成目標が定義されています');
    }
    if (blockTypes.includes('thinking_observe')) {
      insights.push('- **現状分析**: OBSERVEブロックで客観的な観察が行われています');
    }
    if (blockTypes.includes('thinking_reflect')) {
      insights.push('- **振り返り**: REFLECTブロックで改善点が検討されています');
    }

    return insights.length > 0 ? insights.join('\n') : '- 基本的な思考要素が配置されています';
  }

  private checkCompleteFlow(blocks: any[]): boolean {
    const blockTypes = blocks.map(b => b.type).filter(Boolean);
    return blockTypes.includes('thinking_why') && 
           blockTypes.includes('thinking_how') && 
           blockTypes.includes('thinking_what');
  }

  private calculateComplexity(blocks: any[]): 'simple' | 'moderate' | 'complex' {
    const count = blocks.length;
    if (count <= 2) return 'simple';
    if (count <= 5) return 'moderate';
    return 'complex';
  }

  private getThemeColors(theme: string) {
    const themes: { [key: string]: any } = {
      creative: {
        primary: '#8B5CF6',
        background: '#FDF4FF',
        text: '#581C87'
      },
      introspection: {
        primary: '#0EA5E9',
        background: '#F0F9FF',
        text: '#0C4A6E'
      },
      research: {
        primary: '#10B981',
        background: '#F0FDF4',
        text: '#064E3B'
      },
      education: {
        primary: '#F59E0B',
        background: '#FFFBEB',
        text: '#92400E'
      }
    };
    return themes[theme] || themes.creative;
  }

  private getBlockColor(blockType: string): string {
    const colors: { [key: string]: string } = {
      'thinking_why': '#FFD54F',
      'thinking_how': '#81C784',
      'thinking_what': '#64B5F6',
      'thinking_observe': '#FFB74D',
      'thinking_reflect': '#BA68C8',
      'thinking_connect': '#9575CD'
    };
    return colors[blockType] || '#9E9E9E';
  }

  private calculateSVGPositions(blocks: any[], width: number, height: number): Array<{x: number, y: number}> {
    const positions: Array<{x: number, y: number}> = [];
    const centerX = width / 2;
    const centerY = height / 2;

    blocks.forEach((_, index) => {
      const angle = (index * 2 * Math.PI) / blocks.length;
      const radius = Math.min(width, height) * 0.25;
      
      positions.push({
        x: centerX + Math.cos(angle) * radius,
        y: centerY + Math.sin(angle) * radius
      });
    });

    return positions;
  }

  private generateSVGConnections(blocks: any[], positions: any[]): string {
    let connections = '';
    // 簡単な接続線の実装（実際のブロック接続に基づいて改善可能）
    for (let i = 0; i < positions.length - 1; i++) {
      const from = positions[i];
      const to = positions[i + 1];
      connections += `
  <line x1="${from.x}" y1="${from.y}" x2="${to.x}" y2="${to.y}" stroke="#9E9E9E" stroke-width="2" stroke-dasharray="5,5" opacity="0.5"/>`;
    }
    return connections;
  }

  private truncateText(text: string, maxLength: number): string {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }
}

export const exportService = new ThinkingExportService();