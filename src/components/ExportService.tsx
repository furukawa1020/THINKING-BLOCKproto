'use client';

interface ExportService {
  exportAsMarkdown(outputData: any, theme: string): string;
  exportAsJSON(outputData: any, theme: string): string;
  exportAsSVG(blocks: any[], theme: string): string;
  downloadFile(content: string, filename: string, mimeType: string): void;
}

class ThinkingExportService implements ExportService {
  exportAsMarkdown(outputData: any, theme: string): string {
    const { text, json } = outputData;
    const timestamp = new Date().toLocaleString('ja-JP');
    
    const markdown = `# ğŸ§  æ€è€ƒæ§‹é€ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

**ç”Ÿæˆæ—¥æ™‚:** ${timestamp}  
**ãƒ†ãƒ¼ãƒ:** ${this.getThemeName(theme)}

## ğŸ“ æ€è€ƒæ§‹æ–‡

\`\`\`
${text}
\`\`\`

## ğŸ§© ãƒ–ãƒ­ãƒƒã‚¯æ§‹é€ 

${this.generateBlockMarkdown(json.thinking_structure?.blocks || [])}

## ğŸ’¡ è€ƒå¯Ÿ

ã“ã®æ€è€ƒæ§‹é€ ã¯ä»¥ä¸‹ã®è¦ç´ ã‹ã‚‰æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ï¼š

${this.generateInsightMarkdown(json.thinking_structure?.blocks || [])}

## ğŸ”— æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

- [ ] æ€è€ƒæ§‹é€ ã‚’å®Ÿéš›ã®è¡Œå‹•è¨ˆç”»ã«è½ã¨ã—è¾¼ã‚€
- [ ] ä»–ã®è¦–ç‚¹ã‹ã‚‰ã®æ¤œè¨¼ã‚’è¡Œã†  
- [ ] å®šæœŸçš„ãªæŒ¯ã‚Šè¿”ã‚Šã¨æ›´æ–°ã‚’å®Ÿæ–½ã™ã‚‹

---
*Generated by THINKING BLOCKS - Program your way of thinking*
`;

    return markdown;
  }

  exportAsJSON(outputData: any, theme: string): string {
    const enrichedData = {
      ...outputData.json,
      metadata: {
        exportedAt: new Date().toISOString(),
        theme: theme,
        version: '1.0.0',
        generator: 'THINKING BLOCKS'
      },
      analysis: {
        blockCount: outputData.blocks?.length || 0,
        hasCompleteFlow: this.checkCompleteFlow(outputData.blocks || []),
        complexity: this.calculateComplexity(outputData.blocks || [])
      }
    };

    return JSON.stringify(enrichedData, null, 2);
  }

  exportAsSVG(blocks: any[], theme: string): string {
    const width = 800;
    const height = 600;
    const themeColors = this.getThemeColors(theme);

    // SVGãƒ˜ãƒƒãƒ€ãƒ¼
    let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .title { font-family: 'Quicksand', sans-serif; font-size: 18px; font-weight: bold; fill: ${themeColors.text}; }
      .block-text { font-family: 'Quicksand', sans-serif; font-size: 12px; fill: white; text-anchor: middle; }
      .block-label { font-family: 'Quicksand', sans-serif; font-size: 10px; fill: white; text-anchor: middle; }
    </style>
    <filter id="shadow">
      <feDropShadow dx="2" dy="2" stdDeviation="3" flood-opacity="0.3"/>
    </filter>
  </defs>
  
  <!-- Background -->
  <rect width="${width}" height="${height}" fill="${themeColors.background}"/>
  
  <!-- Title -->
  <text x="${width/2}" y="30" text-anchor="middle" class="title">æ€è€ƒæ§‹é€ ãƒãƒƒãƒ—</text>`;

    // ãƒ–ãƒ­ãƒƒã‚¯ã®é…ç½®ã¨ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    if (blocks && blocks.length > 0) {
      const positions = this.calculateSVGPositions(blocks, width, height);
      
      blocks.forEach((block, index) => {
        if (block && block.getFieldValue) {
          const pos = positions[index];
          const text = block.getFieldValue('TEXT') || '';
          const blockType = block.type;
          const color = this.getBlockColor(blockType);
          
          // ãƒ–ãƒ­ãƒƒã‚¯çŸ©å½¢
          svg += `
  <rect x="${pos.x - 60}" y="${pos.y - 20}" width="120" height="40" rx="20" fill="${color}" filter="url(#shadow)"/>
  <text x="${pos.x}" y="${pos.y - 8}" class="block-label">${blockType.replace('thinking_', '').toUpperCase()}</text>
  <text x="${pos.x}" y="${pos.y + 8}" class="block-text">${this.truncateText(text, 15)}</text>`;
        }
      });

      // æ¥ç¶šç·šã®æç”»
      svg += this.generateSVGConnections(blocks, positions);
    } else {
      // ç©ºã®çŠ¶æ…‹
      svg += `
  <text x="${width/2}" y="${height/2}" text-anchor="middle" fill="${themeColors.text}" font-family="Quicksand" font-size="14">
    æ€è€ƒãƒ–ãƒ­ãƒƒã‚¯ã‚’çµ„ã¿ç«‹ã¦ã¦SVGã‚’ç”Ÿæˆã—ã¦ãã ã•ã„
  </text>`;
    }

    svg += `
  <!-- Footer -->
  <text x="${width-10}" y="${height-10}" text-anchor="end" fill="${themeColors.text}" font-family="Quicksand" font-size="10">
    THINKING BLOCKS
  </text>
</svg>`;

    return svg;
  }

  downloadFile(content: string, filename: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  private getThemeName(theme: string): string {
    const themeNames: { [key: string]: string } = {
      creative: 'å‰µé€ ',
      introspection: 'å†…çœ',
      research: 'ç ”ç©¶',
      education: 'æ•™è‚²'
    };
    return themeNames[theme] || theme;
  }

  private generateBlockMarkdown(blocks: any[]): string {
    if (!blocks || blocks.length === 0) {
      return '*ãƒ–ãƒ­ãƒƒã‚¯ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“*';
    }

    return blocks.map((block, index) => {
      const type = block.type || 'unknown';
      const text = block.text || '';
      const typeDisplay = type.replace('thinking_', '').toUpperCase();
      
      return `### ${index + 1}. ${typeDisplay}ãƒ–ãƒ­ãƒƒã‚¯
**å†…å®¹:** ${text}  
**ã‚¿ã‚¤ãƒ—:** \`${type}\`  
**ä½ç½®:** (${block.position?.x || 0}, ${block.position?.y || 0})`;
    }).join('\n\n');
  }

  private generateInsightMarkdown(blocks: any[]): string {
    const blockTypes = blocks.map(b => b.type).filter(Boolean);
    const insights = [];

    if (blockTypes.includes('thinking_why')) {
      insights.push('- **å‹•æ©Ÿã®æ˜ç¢ºåŒ–**: WHYãƒ–ãƒ­ãƒƒã‚¯ã§æ ¹æœ¬çš„ãªå‹•æ©ŸãŒæ•´ç†ã•ã‚Œã¦ã„ã¾ã™');
    }
    if (blockTypes.includes('thinking_how')) {
      insights.push('- **æ‰‹æ®µã®å…·ä½“åŒ–**: HOWãƒ–ãƒ­ãƒƒã‚¯ã§å®Ÿç¾æ–¹æ³•ãŒæ¤œè¨ã•ã‚Œã¦ã„ã¾ã™');
    }
    if (blockTypes.includes('thinking_what')) {
      insights.push('- **ç›®æ¨™ã®è¨­å®š**: WHATãƒ–ãƒ­ãƒƒã‚¯ã§é”æˆç›®æ¨™ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™');
    }
    if (blockTypes.includes('thinking_observe')) {
      insights.push('- **ç¾çŠ¶åˆ†æ**: OBSERVEãƒ–ãƒ­ãƒƒã‚¯ã§å®¢è¦³çš„ãªè¦³å¯ŸãŒè¡Œã‚ã‚Œã¦ã„ã¾ã™');
    }
    if (blockTypes.includes('thinking_reflect')) {
      insights.push('- **æŒ¯ã‚Šè¿”ã‚Š**: REFLECTãƒ–ãƒ­ãƒƒã‚¯ã§æ”¹å–„ç‚¹ãŒæ¤œè¨ã•ã‚Œã¦ã„ã¾ã™');
    }

    return insights.length > 0 ? insights.join('\n') : '- åŸºæœ¬çš„ãªæ€è€ƒè¦ç´ ãŒé…ç½®ã•ã‚Œã¦ã„ã¾ã™';
  }

  private checkCompleteFlow(blocks: any[]): boolean {
    const blockTypes = blocks.map(b => b.type).filter(Boolean);
    return blockTypes.includes('thinking_why') && 
           blockTypes.includes('thinking_how') && 
           blockTypes.includes('thinking_what');
  }

  private calculateComplexity(blocks: any[]): 'simple' | 'moderate' | 'complex' {
    const count = blocks.length;
    if (count <= 2) return 'simple';
    if (count <= 5) return 'moderate';
    return 'complex';
  }

  private getThemeColors(theme: string) {
    const themes: { [key: string]: any } = {
      creative: {
        primary: '#8B5CF6',
        background: '#FDF4FF',
        text: '#581C87'
      },
      introspection: {
        primary: '#0EA5E9',
        background: '#F0F9FF',
        text: '#0C4A6E'
      },
      research: {
        primary: '#10B981',
        background: '#F0FDF4',
        text: '#064E3B'
      },
      education: {
        primary: '#F59E0B',
        background: '#FFFBEB',
        text: '#92400E'
      }
    };
    return themes[theme] || themes.creative;
  }

  private getBlockColor(blockType: string): string {
    const colors: { [key: string]: string } = {
      'thinking_why': '#FFD54F',
      'thinking_how': '#81C784',
      'thinking_what': '#64B5F6',
      'thinking_observe': '#FFB74D',
      'thinking_reflect': '#BA68C8',
      'thinking_connect': '#9575CD'
    };
    return colors[blockType] || '#9E9E9E';
  }

  private calculateSVGPositions(blocks: any[], width: number, height: number): Array<{x: number, y: number}> {
    const positions: Array<{x: number, y: number}> = [];
    const centerX = width / 2;
    const centerY = height / 2;

    blocks.forEach((_, index) => {
      const angle = (index * 2 * Math.PI) / blocks.length;
      const radius = Math.min(width, height) * 0.25;
      
      positions.push({
        x: centerX + Math.cos(angle) * radius,
        y: centerY + Math.sin(angle) * radius
      });
    });

    return positions;
  }

  private generateSVGConnections(blocks: any[], positions: any[]): string {
    let connections = '';
    // ç°¡å˜ãªæ¥ç¶šç·šã®å®Ÿè£…ï¼ˆå®Ÿéš›ã®ãƒ–ãƒ­ãƒƒã‚¯æ¥ç¶šã«åŸºã¥ã„ã¦æ”¹å–„å¯èƒ½ï¼‰
    for (let i = 0; i < positions.length - 1; i++) {
      const from = positions[i];
      const to = positions[i + 1];
      connections += `
  <line x1="${from.x}" y1="${from.y}" x2="${to.x}" y2="${to.y}" stroke="#9E9E9E" stroke-width="2" stroke-dasharray="5,5" opacity="0.5"/>`;
    }
    return connections;
  }

  private truncateText(text: string, maxLength: number): string {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }
}

export const exportService = new ThinkingExportService();